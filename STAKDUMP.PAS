{/////////////////////////////////////////////////////////////////////////
//
//  Dos Navigator Open Source 1.51.10
//  Based on Dos Navigator (C) 1991-99 RIT Research Labs
//
//  This programs is free for commercial and non-commercial use as long as
//  the following conditions are aheared to.
//
//  Copyright remains RIT Research Labs, and as such any Copyright notices
//  in the code are not to be removed. If this package is used in a
//  product, RIT Research Labs should be given attribution as the RIT Research
//  Labs of the parts of the library used. This can be in the form of a textual
//  message at program startup or in documentation (online or textual)
//  provided with the package.
//
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are
//  met:
//
//  1. Redistributions of source code must retain the copyright
//     notice, this list of conditions and the following disclaimer.
//  2. Redistributions in binary form must reproduce the above copyright
//     notice, this list of conditions and the following disclaimer in the
//     documentation and/or other materials provided with the distribution.
//  3. All advertising materials mentioning features or use of this software
//     must display the following acknowledgement:
//     "Based on Dos Navigator by RIT Research Labs."
//
//  THIS SOFTWARE IS PROVIDED BY RIT RESEARCH LABS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
//  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
//  DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR
//  ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
//  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
//  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
//  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
//  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
//  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
//  ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//  The licence and distribution terms for any publically available
//  version or derivative of this code cannot be changed. i.e. this code
//  cannot simply be copied and put under another distribution licence
//  (including the GNU Public Licence).
//
//////////////////////////////////////////////////////////////////////////}
{********************************************************************
 STAKDUMP.PAS - a unit for dumping the stack chain of Turbo Pascal
 programs. This is useful for finding the real cause of runtime
 errors, especially when a low level routine that is called from many
 places generates the error. See STAKDUMP.DOC for more information.

 Written by Kim Kokkonen, TurboPower Software.
 Released to the public domain.

 Version History:
   1.0 11/27/87
      initial release
   1.x 09/18/89
      trace Turbo Pascal 5.x overlays (provided by Per Larsen)
   2.0 10/25/90
      make it work better with TSRs
   2.01 9/25/91
      fix hang bug running on TP6 programs
   2.02 10/16/91
      fix problem that occurs when scanning garbage code
   2.03 12/18/91
      adds instructions generated by $G+
   3.0 9/24/92
      rewritten. Now supports TP6 or later only, and works in
      real or protected mode with BP7. New routine DumpStack provides
      a stack dump on demand. New routines OpenOutput, CloseOutput,
      and WriteOutput allow writing the dumps to a specified file.
********************************************************************}

{$IFDEF Windows}
  !! Error: not compatible with TPW
{$ENDIF}

{$S-,R-,V-,I-,B-,F-,A-,X-}
{$IFDEF DPMI}
  {$G+}
  {$C DEMANDLOAD,DISCARDABLE}
{$ENDIF}

unit StakDump;
  {-Stack dump for real or protected mode}

interface

Procedure StakDumpInitUnit;

procedure DumpStack;
  {-Dump the current stack chain, starting at this routine's return address}

procedure TraceStack(StartAddr : Pointer);

procedure OpenOutput(FName : String);
  {-Create and open an alternate file for output reporting}

procedure AssignOutput(FHandle : Word);
  {-Assign the output file handle} {DataCompBoy}

procedure CloseOutput;
  {-Close alternate output file}

procedure WriteOutput(S : String);
  {-Write a string to the output file}

{$IFDEF DPMI}
function FindPhysAddr(LogAddr : Pointer) : Pointer;
  {-Return the selector:offset address for given logical segment:offset}
{$ENDIF}

{========================================================================}

implementation

type
  OS = record
         O, S : Word;
       end;
var
  ExitSave : Pointer;{Exit procedure chain}
  OutHandle : Word;  {Handle of file to write to. 1 = StdOut}
  {$IFDEF DPMI}
  ProgSele : Word;   {Selector of main program's code segment}
  {$ENDIF}
  CharBuf : Byte;    {Buffer for convenient writing}

procedure OpenOutput(FName : String);
var
  Len : Byte;
begin
  Len := Length(FName);
  move(FName[1], FName[0], Len);
  FName[Len] := #0;
  asm
    push ds
    push ss
    pop  ds
    lea  dx,FName
    mov  ah,$3C
    xor  cx,cx
    int  $21
    pop  ds
    jc   @1
    mov  OutHandle,ax
    xor  ax,ax
@1: mov  InOutRes,ax
  end;
end;

 {-DataCompBoy-}
procedure AssignOutput; assembler;
asm
 mov AX, FHandle
 mov OutHandle, AX
end;

procedure CloseOutput; assembler;
asm
    mov  bx,OutHandle
    mov  ah,$3E
    int  $21
    jc   @1
    xor  ax,ax
@1: mov  InOutRes,ax
end;

procedure WriteOutput(S : String); assembler;
asm
    mov  ah,$40
    mov  bx,OutHandle
    push ds
    lds  si,S
    xor  cx,cx
    mov  cl,[si]
    mov  dx,si
    inc  dx
    int  $21
    pop  ds
    jc   @1
    xor  ax,ax
@1: mov  InOutRes,ax
end;

procedure WriteAlAscii; assembler;
asm
    mov  CharBuf,al
    mov  ah,$40
    mov  bx,OutHandle
    mov  cx,1
    mov  dx,offset CharBuf
    int  $21
end;

procedure WriteAxHex; assembler;
asm
    push ax
    mov  al,ah
    call @1
    pop  ax
@1: push ax
    mov  cl,4
    shr  al,cl
    call @2
    pop  ax
    and  al,$0F
@2: add  al,'0'
    cmp  al,'9'
    jbe  @3
    add  al,07
@3: call WriteAlAscii
end;

const
  {Used to compute length of each instruction}
  InstrTable : array[0..255] of byte = (
    {0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F}
    09, 09, 09, 09, 02, 03, 01, 01, 09, 09, 09, 09, 02, 03, 01, 32,  {0}
    09, 09, 09, 09, 02, 03, 01, 01, 09, 09, 09, 09, 02, 03, 01, 01,  {1}
    09, 09, 09, 09, 02, 03, 01, 01, 09, 09, 09, 09, 02, 03, 01, 01,  {2}
    09, 09, 09, 09, 02, 03, 01, 01, 09, 09, 09, 09, 02, 03, 01, 01,  {3}
    01, 01, 01, 01, 01, 01, 01, 01, 01, 01, 01, 01, 01, 01, 01, 01,  {4}
    01, 01, 01, 01, 01, 01, 01, 01, 01, 01, 01, 01, 01, 01, 01, 01,  {5}
    01, 01, 32, 32, 01, 01, 01, 01, 03, 11, 02, 10, 32, 32, 01, 01,  {6}
    02, 02, 02, 02, 02, 02, 02, 02, 02, 02, 02, 02, 02, 02, 02, 02,  {7}
    10, 11, 10, 10, 09, 09, 09, 09, 09, 09, 09, 09, 09, 09, 09, 09,  {8}
    01, 01, 01, 01, 01, 01, 01, 01, 01, 01, 05, 01, 01, 01, 01, 01,  {9}
    03, 03, 03, 03, 01, 01, 01, 01, 02, 03, 01, 01, 01, 01, 01, 01,  {A}
    02, 02, 02, 02, 02, 02, 02, 02, 03, 03, 03, 03, 03, 03, 03, 03,  {B}
    10, 10, 03, 01, 09, 09, 10, 11, 04, 01, 03, 01, 01, 02, 01, 01,  {C}
    09, 09, 09, 09, 01, 01, 32, 01, 09, 09, 09, 09, 09, 09, 09, 09,  {D}
    02, 02, 02, 02, 02, 02, 02, 02, 03, 03, 05, 02, 01, 01, 01, 01,  {E}
    01, 32, 01, 01, 01, 01, 18, 19, 01, 01, 01, 01, 01, 01, 09, 09   {F}
    );

    {Notes: 32 in table means an invalid or unsupported opcode.
            Instructions not supported:
              $0F    286/386/486 extended opcode prefix
              $62    BOUND
              $63    ARPL
            Generally, instructions with 32-bit addresses or operands
              are not supported.
    }

procedure RmLength; assembler;
  {Entry: AH = mod reg r/m byte to decode
          BX = instruction length so far
   Exit:  BX = total instruction length
          AX destroyed}
asm
    mov  al,ah                  {AL = next byte}
    and  al,$C0                 {AL = mod field}
    or   al,al                  {Direct addressing mode? }
    jnz  @4                     {No, check again}
    and  ah,7                   {AH = r/m field}
    cmp  ah,6                   {No base register mode? }
    jne  @1                     {No, just one byte of instruction}
    jmp  @3
@4: cmp  al,$40                 {One byte displacement mode? }
    je   @2                     {Yes, two bytes of instruction}
    cmp  al,$80                 {Two byte displacement mode? }
    jne  @1                     {No, just one byte of instruction}
@3: inc  bx
@2: inc  bx
@1: inc  bx
end;

procedure NextIP; assembler;
  {Entry: ES:DI points to current instruction
   Exit:  ES:DI points to next instruction
          AX,BX destroyed
          CF set if disassembly error}
asm
    mov  ax,es:[di]             {get next word of code}
    mov  bx,offset InstrTable   {point to instruction table}
    xlat                        {AL = instruction code delta}
    mov  bl,al                  {Save delta}
    xor  bh,bh
    and  bl,7                   {BX = instruction length}
    and  al,$F8                 {Separate instruction type}
    or   al,al                  {Itype = 0? }
    jz   @4                     {Jump if so}
    cmp  al,08                  {Itype = 8? }
    jne  @2                     {Jump if not}
@1: call RmLength               {Get addressing length}
    jmp  @4
@2: cmp  al,$10                 {Itype = $10? }
    jne  @3                     {No, error}
    mov  al,ah                  {AL = next byte of code}
    and  al,$38
    or   al,al
    jz   @1                     {Add RM and we're done}
    mov  bx,1                   {Base length is one}
    jmp  @1
@3: stc
    ret
@4: add  di,bx                  {Point DI to next}
end;

procedure IsFarProc; assembler;
  {Entry: ES:DI points to current instruction
   Exit:  ES:DI still points to current instruction
          ZF set if current procedure is NEAR
          CF set if disassembly error
          AX,BX destroyed}
asm
    push di                     {save IP value}
    clc                         {clear error flag}
@1: mov  al,es:[di]             {get next instruction}
    cmp  al,0C2h                {see if any RET instruction}
    je   @2
    cmp  al,0C3h                {see if any RET instruction}
    je   @2
    cmp  al,0CAh                {see if any RET instruction}
    je   @2
    cmp  al,0CBh                {see if any RET instruction}
    je   @2
    call NextIP                 {advance to next instruction}
    jnc  @1                     {loop if no error}
@2: test al,$08                 {is FAR bit set? }
    pop  di
end;

{$IFDEF DPMI}
procedure TraceStack(StartAddr : Pointer); assembler;
  {-Trace and dump stack, starting at code address StartAddr. PMode version}
asm
    les  di,StartAddr           {es:di -> physical start address of code}
    mov  si,[bp]
    mov  si,ss:[si]             {skip stack frame of this routine}
@1: mov  ax,es:[0]              {ax = logical code segment}
    call WriteAxHex
    mov  al,':'
    call WriteAlAscii
    mov  ax,di                  {ax = code offset}
    call WriteAxHex
    mov  al,13
    call WriteAlAscii           {write CR/LF}
    mov  al,10
    call WriteAlAscii
    cmp  word ptr ss:[si],0     {end of chain? }
    je   @3
    call IsFarProc
    jc   @3                     {exit if disassembly error}
    jz   @2
    mov  ax,ss:[si+4]           {ax = possible new code segment}
    verr ax                     {verify valid segment for reading}
    jnz  @3                     {jump if invalid segment}
    mov  es,ax
@2: mov  di,ss:[si+2]           {di = new code offset}
    mov  si,ss:[si]             {si = new BP}
    jmp  @1                     {loop to next scope}
@3:
end;

{$ELSE}

procedure FindOverlay; assembler;
  {Entry: ES:DI is current return address
          CX is segment load fixup
   Exit:  DX is physical segment, 0 if not available
          AX,BX destroyed}
asm
    mov  bx,es                  {Save segment in BX}
    mov  dx,bx                  {Default return value in DX, if not in overlay}
    mov  ax,OvrCodeList         {Walk through overlays, if any}
@1: or   ax,ax                  {More overlays? }
    jz   @4                     {Jump if not}
    add  ax,cx                  {Fixup for load base}
    mov  es,ax
    cmp  bx,es:[16]             {Physical overlaid segment? }
    je   @2
    cmp  bx,ax                  {Static overlaid segment? }
    je   @3
    mov  ax,es:[14]             {Next overlay segment}
    jmp  @1
@2: mov  bx,es                  {Convert physical to static}
@3: mov  dx,es:[16]             {Load physical from overlay control block}
    or   di,di
    jnz  @4
    mov  di,es:[2]              {Restore offset from overlay control block}
@4: mov  es,bx                  {Restore segment from ES}
end;

procedure TraceStack(StartAddr : Pointer); assembler;
  {-Trace and dump stack, starting at code address StartAddr. RMode version}
asm
    les  di,StartAddr           {es:di -> physical start address of code}
    mov  si,[bp]
    mov  si,ss:[si]             {skip stack frame of this routine}
    mov  cx,PrefixSeg
    add  cx,$10                 {CX = segment load fixup}
@1: call FindOverlay            {returns physical segment in DX}
    push dx                     {save segment}
    push cx                     {save fixup}
    mov  ax,es
    sub  ax,cx                  {AX = relative segment}
    call WriteAxHex
    mov  al,':'
    call WriteAlAscii
    mov  ax,di                  {ax = code offset}
    call WriteAxHex
    mov  al,13
    call WriteAlAscii           {write CR/LF}
    mov  al,10
    call WriteAlAscii
    pop  cx                     {restore fixup}
    pop  dx                     {restore physical segment}
    cmp  word ptr ss:[si],0     {end of chain? }
    je   @3
    or   dx,dx                  {is code available? }
    jz   @4                     {assume far if not}
    push es
    mov  es,dx
    call IsFarProc
    pop  es
    jc   @3                     {exit if disassembly error}
    jz   @2
@4: mov  es,ss:[si+4]           {ES = new code segment}
@2: mov  di,ss:[si+2]           {di = new code offset}
    mov  si,ss:[si]             {si = new BP}
    jmp  @1                     {loop to next scope}
@3:
end;
{$ENDIF}

procedure DumpStack; assembler;
asm
  push bp
  mov  bp,sp
  {Push the return address of this procedure}
  push word ptr [bp+4]
  push word ptr [bp+2]
  call TraceStack
  pop  bp
end;

{$IFDEF DPMI}
function ValidSele(Sele : Word) : Boolean; assembler;
  {-Return True if Sele is valid for reading}
asm
  verr Sele
  mov  al,0
  jnz  @1
  inc  al
@1:
end;

{.$DEFINE FastAndDirty}
{$IFDEF FastAndDirty}
{This routine uses information in the instance's module table. Given
 the dependence on hard coded offsets, it appears to be subject to
 change.}
function FindPhysAddr(LogAddr : Pointer) : Pointer;
  {-Return the selector:offset address for given logical segment:offset}
begin
  FindPhysAddr := Ptr(MemW[HInstance:$00F2+32*(OS(LogAddr).S-1)],
                      OS(LogAddr).O);
end;
{$ELSE}
function FindPhysAddr(LogAddr : Pointer) : Pointer;
  {-Return the selector:offset address for given logical segment:offset}
var
  LogExp : Word;
  LogTgt : Word;
  Sele : Word;
begin
  FindPhysAddr := nil;
  LogTgt := OS(LogAddr).S;
  if LogTgt <> $FFFF then begin
    {The logical address represents a valid code selector}
    LogExp := 1;
    Sele := ProgSele;
    repeat
      if not ValidSele(Sele) then
        {Invalid selector. Avoid a GPF}
        Exit;
      if MemW[Sele:0] <> LogExp then
        {Logical segment trace is off the track}
        Exit;
      if LogExp = LogTgt then begin
        {Found target selector}
        FindPhysAddr := Ptr(Sele, OS(LogAddr).O);
        Exit;
      end;
      {Next logical segment}
      inc(LogExp);
      {Next code selector (note 2 selectors per code segment)}
      inc(Sele, 2*SelectorInc);
    until LogExp > 1024; {Terminate eventually just in case}
  end;
end;
{$ENDIF}
{$ENDIF}

procedure DumpExit; far;
var
  PhysAddr : Pointer;
  ExitStr : String[9];
begin
  ExitProc := ExitSave;
  if ErrorAddr <> nil then begin
    {An error occurred, not a normal halt}
    {$IFDEF DPMI}
    PhysAddr := FindPhysAddr(ErrorAddr);
    {$ELSE}
    PhysAddr := Ptr(OS(ErrorAddr).S+PrefixSeg+$10, OS(ErrorAddr).O);
    {$ENDIF}
    if PhysAddr <> nil then begin
      {Able to translate logical address into physical}
      Assign(Output, '');
      Rewrite(Output);
      WriteOutput(^M^J'Runtime error ');
      Str(ExitCode, ExitStr);
      WriteOutput(ExitStr);
      WriteOutput(' at'^M^J);
      TraceStack(PhysAddr);
      ErrorAddr := nil;
      CloseOutput;
    end;
  end;
end;

Procedure StakDumpInitUnit;
begin
  {$IFDEF DPMI}
  {Save the selector of program's main code segment}
  asm
    mov ax,[bp+4]
    mov ProgSele,ax
  end;
  {$ENDIF}
  {Write to standard output by default}
  OutHandle := 1;
  {Install stack dump exit handler}
  ExitSave := ExitProc;
  ExitProc := @DumpExit;
END;

end.
