{/////////////////////////////////////////////////////////////////////////
//
//  Dos Navigator Open Source
//  Based on Dos Navigator (C) 1991-99 RIT Research Labs
//
//  This programs is free for commercial and non-commercial use as long as
//  the following conditions are aheared to.
//
//  Copyright remains RIT Research Labs, and as such any Copyright notices
//  in the code are not to be removed. If this package is used in a
//  product, RIT Research Labs should be given attribution as the RIT Research
//  Labs of the parts of the library used. This can be in the form of a textual
//  message at program startup or in documentation (online or textual)
//  provided with the package.
//
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are
//  met:
//
//  1. Redistributions of source code must retain the copyright
//     notice, this list of conditions and the following disclaimer.
//  2. Redistributions in binary form must reproduce the above copyright
//     notice, this list of conditions and the following disclaimer in the
//     documentation and/or other materials provided with the distribution.
//  3. All advertising materials mentioning features or use of this software
//     must display the following acknowledgement:
//     "Based on Dos Navigator by RIT Research Labs."
//
//  THIS SOFTWARE IS PROVIDED BY RIT RESEARCH LABS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
//  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
//  DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR
//  ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
//  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
//  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
//  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
//  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
//  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
//  ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//  The licence and distribution terms for any publically available
//  version or derivative of this code cannot be changed. i.e. this code
//  cannot simply be copied and put under another distribution licence
//  (including the GNU Public Licence).
//
//////////////////////////////////////////////////////////////////////////
//
//  Version history:
//
//  1.6.RC1
//  dn16rc1-Error_message_fix-diff157byMV.patch
//
//  2.0.0
//  dn3421-Kernel(f)-8_and_2_on_key_pad_fix.patch
//
//  3.7.0
//  dn370-clock(i)-disable_seconds_in_winnt.patch
//
//  4.9.0
//  dn50208-cleanup.patch
//
//  5.9.0
//
//////////////////////////////////////////////////////////////////////////}

var
  Ticks: Word absolute $40:$6C;
  SaveExit: Pointer;
  ShiftWasPressed: Boolean;  {John_SW 13-07-2003}

{$IFDEF DNPRG}
Procedure FatalError ;

var
  C,AC : Word;
  B : array[0..42] of Word;
  I : Byte;
  t : text;

function GetCoord(X, Y: LongInt): Word;
begin
 GetCoord := ((ScreenHeight-8) div 2+Y)*(ScreenWidth*2)+((ScreenWidth-40) div 2+X)*2;
end;


procedure NewLine;
var CO : word ;
  begin


  MoveChar(B, ' ', Byte(C), 42 );

   if  I in [0,8] then
      MoveChar(B, #205, Byte(C), 42)
       else
         begin
           MoveChar(B,     #186, Byte(C), 1);
           MoveChar(B[41], #186, Byte(C), 1);
         end;

   if  I = 0 then
        begin
         MoveChar(B, #201, Byte(C), 1);
         MoveChar(B[41], #187, Byte(C), 1);
        end;

         CO := C;

   if  I = 8 then
        begin
         MoveChar(B,     #200, Byte(C), 1);
         MoveChar(B[41], #188, Byte(C), 1);
        end;

   if I = 7 then CO := AC;

    if FreeStr<>'' then
         MoveStr(B[ ( 42 - Length(FreeStr)) div 2], FreeStr , Byte(CO));
    Move(B,PByteArray(ScreenBuffer)^[GetCoord(0,I)], 84);

    if I > 0 then
     begin
       PByteArray(ScreenBuffer)^[GetCoord(42,I)+1] := 8;
       PByteArray(ScreenBuffer)^[GetCoord(43,I)+1] := 8;
     end;

  end;

begin
 asm    int     3      {for easy debug}
        MOV     AH,3
        MOV     BH,0

        PUSH    BP
        PUSH    ES
        INT     $10
        POP     ES
        POP     BP

        PUSH    CX
        MOV     AH,1
        MOV     CX,2000H

        PUSH    BP
        PUSH    ES
        INT     $10
        POP     ES
        POP     BP
 end;

 { Create Report File }
 DoDump(ExitCode, Pointer(ErrAdd));

  { Display Error Box }
  if Lo(ScreenMode) = smMono then
    begin C := SysMonoAttr; AC := $0F07 end else
    begin C := SysColorAttr; AC := SysColorButtonAttr end;

   FillWord(Ptr(SegB800, 0)^, ScreenWidth*ScreenHeight, $0F20);
   I := 0 ;
     for I:=0 to 8
      do
       begin
        case I of
             0 : FreeStr := ' Fatal Error ';
             2 : FreeStr := 'Exception 0' + Hex2(ExitCode)
                     + 'h at address '+Hex4( ErrAdd shr 16 ) +
                       ':' + Hex4( ErrAdd );

             4 : FreeStr := 'Report to RU.SHELL.DN';
             5 : FreeStr := '( convert DN.ERR with DNERROR.EXE )';
             6 : FreeStr := '( and send us file DN2SEND.ERR )';
            else FreeStr := '';
        end;
      NewLine;
    end;
  for I := 0 to 41 do
    PByteArray(ScreenBuffer)^[GetCoord(I+2,9)+1] := 8; { shadow }

  asm
        XOR     BH, BH
        MOV     AH, $02
        MOV     DX, $1200
        PUSH    BP
        PUSH    ES
        INT     $10
        POP     ES
        POP     BP
  end;
  Writeln; Writeln('Enter description of problem:');
  Readln(FreeStr);
  SourceDir := SourceDir + 'DN.ERR';
  Assign(T, SourceDir);
  Append(T);
  Writeln(T, 'DESC:'+FreeStr);
  Close(T);
end;
{$ENDIF}


{ Detect mouse driver }
procedure DetectMouse; near; assembler;
asm
        MOV     AX,3533H
        INT     21H
        MOV     AX,ES
        OR      AX,BX
        JE      @@1
        MOV     AX,21H
        INT     33H
        SUB     AX,21H
        JE      @@2
@@3:    PUSH    BX
        MOV     AX,4
        XOR     CX,CX
        XOR     DX,DX
        INT     33H
        POP     AX
        jmp     @@1
@@2:    XOR     AX,AX
        INT     33H
        OR      AX, AX
        JNE     @@3
@@1:    MOV     ButtonCount,AL
end;

{ Store event in GetMouseEvent and GetKeyEvent }

procedure StoreEvent; near; assembler;
asm
        MOV     DI,SP
        LES     DI,SS:[DI+8]
        CLD
        STOSW
        XCHG    AX,BX
        STOSW
        XCHG    AX,CX
        STOSW
        XOR     AX,AX
        STOSW
        XCHG    AX,DX
        STOSW
        XOR     AX,AX
        STOSW
end;

{ Get mouse state }
{ Out   BL = Button mask }
{       CX = X coordinate }
{       DX = Y coordinate }
{       DI = Timer ticks }

procedure GetMouseState;near; assembler;
asm
        CLI
        CMP     EventCount,0
        JNE     @@1
        MOV     BL,MouseButtons
{$IFNDEF BIT_32}
        MOV     CX,MouseWhere.X.Word[0]
        MOV     DX,MouseWhere.Y.Word[0]
{$ELSE}
        MOV     ECX,MouseWhere.X
        MOV     EDX,MouseWhere.Y
{$ENDIF}
        MOV     ES,Seg0040
        MOV     DI,ES:[6Ch]
        JMP     @@3
@@1:    MOV     SI,EventQHead
        CLD
        LODSW
        XCHG    AX,DI
        LODSW
        XCHG    AX,BX
        LODSW
        XCHG    AX,CX
        LODSW
        XCHG    AX,DX
        CMP     SI,OFFSET EventQLast
        JNE     @@2
        MOV     SI,OFFSET EventQueue
@@2:    MOV     EventQHead,SI
        DEC     EventCount
@@3:    STI
        CMP     MouseReverse,0
        JE      @@4
        MOV     BH,BL
        AND     BH,3
        JE      @@4
        CMP     BH,3
        JE      @@4
        XOR     BL,3
@@4:
end;

procedure ShowMouse; assembler;
asm
        CMP     ButtonCount,0
        JE      @@1
        cmp     StdMouse, 0
        je      @@@1
        push    AX
        mov     ax, 1
        int     33h
        pop     AX
        jmp     @@1
      @@@1:
        CMP     MouseVisible, 0
        JNE     @@1
        PUSH    AX
        PUSH    BX
        PUSH    DX
        PUSH    CX
        PUSH    DI
        PUSH    SI
        PUSH    ES
        PUSH    BP
        MOV     MouseVisible, 1
        CALL    ShowMouseProc
        POP     BP
        POP     ES
        POP     SI
        POP     DI
        POP     CX
        POP     DX
        POP     BX
        POP     AX
@@1:
end;

procedure HideMouse; assembler;
asm
        CMP     ButtonCount,0
        JE      @@1
        cmp     StdMouse, 0
        je      @@@1
        push    AX
        mov     ax, 2
        int     33h
        pop     AX
        jmp     @@1
      @@@1:
        {CMP     MouseVisible, 0
        JE      @@1}
        PUSH    AX
        PUSH    BX
        PUSH    DX
        PUSH    CX
        PUSH    DI
        PUSH    SI
        PUSH    ES
        PUSH    BP
        CALL    HideMouseProc
        MOV     MouseVisible, 0
        MOV     OldMouseX, $FFFF
        MOV     OldMouseY, $FFFF
        POP     BP
        POP     ES
        POP     SI
        POP     DI
        POP     CX
        POP     DX
        POP     BX
        POP     AX
@@1:
end;

procedure GetMouseEvent(var Event: TEvent); assembler;
asm
        CMP     MouseEvents,0
        JE      @@2
        CALL    GetMouseState
        MOV     BH,LastDouble
        MOV     AL,LastButtons
        CMP     AL,BL
        JE      @@1
        OR      AL,AL
        JE      @@3
        OR      BL,BL
        JE      @@5
        MOV     BL,AL
{$IFNDEF BIT_32}
@@1:    CMP     CX,LastWhere.X.Word[0]
        JNE     @@6
        CMP     DX,LastWhere.Y.Word[0]
{$ELSE}
@@1:    CMP     ECX,LastWhere.X
        JNE     @@6
        CMP     EDX,LastWhere.Y
{$ENDIF}
        JNE     @@6
        CMP     RepeatDelay, 0
        JE      @@6
        OR      BL,BL
        JE      @@2
        MOV     AX,DI
        SUB     AX,AutoTicks
        CMP     AX,AutoDelay
        JAE     @@7
@@2:    XOR     AX,AX
        MOV     BX,AX
        MOV     CX,AX
        MOV     DX,AX
        JMP     @@9
@@3:    MOV     BH,0
        CMP     BL,DownButtons
        JNE     @@4
{$IFNDEF BIT_32}
        CMP     CX,DownWhere.X.Word[0]
        JNE     @@4
        CMP     DX,DownWhere.Y.Word[0]
{$ELSE}
        CMP     ECX,DownWhere.X
        JNE     @@4
        CMP     EDX,DownWhere.Y
{$ENDIF}
        JNE     @@4
        MOV     AX,DI
        SUB     AX,DownTicks
        CMP     AX,DoubleDelay
        JAE     @@4
        MOV     BH,1
@@4:    MOV     DownButtons,BL
{$IFNDEF BIT_32}
        MOV     DownWhere.X.Word[0],CX
        MOV     DownWhere.Y.Word[0],DX
{$ELSE}
        MOV     DownWhere.X,ECX
        MOV     DownWhere.Y,EDX
{$ENDIF}
        MOV     DownTicks,DI
        MOV     AutoTicks,DI
        MOV     AX,RepeatDelay
        MOV     AutoDelay,AX
        MOV     AX,evMouseDown
        JMP     @@8
@@5:    MOV     AX,evMouseUp
        JMP     @@8
@@6:    MOV     AX,evMouseMove
        JMP     @@8
@@7:    MOV     AutoTicks,DI
        MOV     AX,AutoRepeat
        MOV     AutoDelay,AX
        MOV     AX,evMouseAuto
@@8:    MOV     LastButtons,BL
        MOV     LastDouble,BH
{$IFNDEF BIT_32}
        MOV     LastWhere.X.Word[0],CX
        MOV     LastWhere.Y.Word[0],DX
{$ELSE}
        MOV     LastWhere.X,CX
        MOV     LastWhere.Y,DX
{$ENDIF}
@@9:    CALL    StoreEvent
end;

procedure _GetKeyEvent(var Event: TEvent); assembler;
asm
        MOV     AH,11h
        INT     16H
        MOV     AX,0
        MOV     BX,AX
        JE      @@1
        MOV     AH,10h
        INT     16H


        cmp     ah,$E0
        jne     @NotExt

        cmp     al,$0D
        jne     @NotEnter
        mov     bx,kbEnter
        jmp     @PUT

@NotEnter:


@NotExt:

        XCHG    AX,BX
@PUT:   MOV     AX,evKeyDown
@@1:    XOR     CX,CX
        MOV     DX,CX
        CALL    StoreEvent
end;


procedure GetKeyEvent;
Var
   C: Byte;
   B: TDrawBuffer;
   MemStr: String;
begin
  ShiftState:=mem[Seg0040:$17];
  ShiftState2:=mem[Seg0040:$18];
  _GetKeyEvent(Event);

{--- start -------- Eugeny Zvyagintzev ---- 13-07-2003 -----}
{To display available memory's size}
  If (ShiftState And 3 = 0) And ShiftWasPressed Then
   Begin
    If InterfaceData.Options And ouiHideMenu = 0 Then MenuBar^.Draw
    Else Desktop^.Draw;
    ShiftWasPressed:=False;
   End;
  If (ShiftState And 3 <> 0) And (InterfaceData.Options And ouiClock = 0) Then
   Begin
    ShiftWasPressed:=True;
    C:=Desktop^.GetColor(1);
    MemStr:=' '+FStr(MemAvail)+' ';
    MoveChar(B, ' ', C, Length(MemStr));
    MoveStr(B, MemStr, C);
    If InterfaceData.Options And ouiHideMenu = 0 Then
     MenuBar^.WriteLine(Desktop^.Size.X-Length(MemStr), 0, Length(MemStr), 1, B)
    Else
     Desktop^.WriteLine(Desktop^.Size.X-Length(MemStr), 0, Length(MemStr), 1, B);
   End;
{--- finish -------- Eugeny Zvyagintzev ---- 13-07-2003 ----}
  if Event.What = evNothing then Exit;
{--- start -------- Eugeny Zvyagintzev ---- 11-05-2003 -----}
{KbUpUp,kbDownUp have to be inaccessible}
{when NumLock is On}
  If (ShiftState And 32 <> 0) And
     (Event.ScanCode in [$C8,$D0]) Then
   Begin
    Event.What:=evNothing;
    Exit;
   End;
{--- finish -------- Eugeny Zvyagintzev ---- 11-05-2003 -----}
  if (Event.KeyCode = kbCtrlTab) and (ShiftState and 3 <> 0) then Event.KeyCode := kbAltTab;
  if (Event.CharCode = #$e0) and
     (Event.ScanCode in [$52,$92,$A2,
                         $47,$77,$97,
                         $49,$84,$99,
                         $93,$53,$A3,
                         $4F,$75,$9F,
                         $51,$76,$A1,
                         $48,$8D,$98,
                         $4B,$73,$9B,
                         $50,$91,$A0,
                         $4D,$9D,$74])
  then
                           Event.CharCode := #0
  else
  if Event.What = evKeyDown then
    if (Event.CharCode >= '0') and (Event.CharCode <= '9') and
     (ShiftState and 3 <> 0) then Event.CharCode := #0;
end;

{-----------------------------------------------------}

{ String formatting routines }

{$L FORMAT.OBJ}

procedure Format_Str(var Result: String; const Format: String; var Params);
{$IFDEF BIT_16}far;{$ENDIF} external;

procedure FormatStr;
begin
  if @Params = nil then Result := Format else Format_Str(Result, Format, Params);
end;

procedure PrintStr(const S: String); assembler;
asm
        PUSH    DS
        LDS     SI,S
        CLD
        LODSB
        XOR     AH,AH
        XCHG    AX,CX
        MOV     AH,40H
        MOV     BX,1
        MOV     DX,SI
        INT     21H
        POP     DS
end;

{ Buffer move routines }

procedure MoveBuf(var Dest; var Source; Attr: Byte; Count: Word); assembler;
asm
        MOV     CX,Count
        JCXZ    @@5
        MOV     DX,DS
        LES     DI,Dest
        LDS     SI,Source
        MOV     AH,Attr
        CLD
{       OR      AH,AH
        JE      @@3
}
@@1:    LODSB
        STOSW
        LOOP    @@1
{
        JMP     @@4
@@2:    INC     DI
@@3:    MOVSB
        LOOP    @@2
}
@@4:    MOV     DS,DX
@@5:
end;

procedure MoveChar(var Dest; C: Char; Attr: Byte; Count: Word); assembler;
asm
        MOV     CX,Count
        JCXZ    @@4
        LES     DI,Dest
        MOV     AL,C
        MOV     AH,Attr
        CLD
        OR      AL,AL
        JE      @@1
        {
        OR      AH,AH
        JE      @@3
        }
        REP     STOSW
        JMP     @@4
@@1:    MOV     AL,AH
@@2:    INC     DI
@@3:    STOSB
        LOOP    @@2
@@4:

end;

procedure MoveCStr(var Dest; const Str: String; Attrs: Word); assembler;
asm
        MOV     DX,'~'
        PUSH    DS
        LDS     SI,Str
        CLD
        LODSB
        MOV     CL,AL
        XOR     CH,CH
        JCXZ    @OUT
        LES     DI,Dest
        MOV     BX,Attrs
        MOV     AH,BL
@LP:    LODSB
        CMP     AL,0
        JE      @NULL
        CMP     AL,DL
        JE      @TILDE
        STOSW
        LOOP    @LP
        JMP     @OUT
@NULL:  XCHG    DL,DH
        LOOP    @LP
        JMP     @OUT
@TILDE: XCHG    AH,BH
        LOOP    @LP
@OUT:   POP     DS
end;

procedure MoveStr(var Dest; const Str: String; Attr: Byte); assembler;
asm
        MOV     DX,DS
        LDS     SI,Str
        CLD
        LODSB
        MOV     CL,AL
        XOR     CH,CH
        JCXZ    @@4
        LES     DI,Dest
        MOV     AH,Attr

        {OR      AH,AH
        JE      @@3}

@@1:    LODSB
        STOSW
        LOOP    @@1
{
        JMP     @@4

@@2:    INC     DI
@@3:    MOVSB
        LOOP    @@2
}
@@4:    MOV     DS,DX
end;

function CStrLen(const S: String): Integer; assembler;
asm
        MOV     DL,'~'
        LES     DI,S
        MOV     CL,ES:[DI]
        INC     DI
        XOR     CH,CH
        MOV     BX,CX
        JCXZ    @@2
@@LOD:  MOV     AL, ES:[DI]
        INC     DI
        CMP     AL,DL
        JE      @@DEC
        CMP     AL,0
        JNE     @@AA
        MOV     DL,0
@@DEC:  DEC     BX
@@AA:   LOOP    @@LOD
@@2:    MOV     AX,BX
end;

procedure MoveColor(var Buf; Num, Attr: Byte);assembler;
asm
   les    bx,Buf
   xor    ch,ch
   mov    cl,Num
   or     cl,cl
   jz     @End
   mov    al,Attr
@Rep:
   mov    es:[bx+1],al
   add    bx,2
   loop   @Rep
@End:
end;

procedure MakeCoords; near; assembler;
asm
    les  bx, ScreenBuffer
    mov  ax, si
    mov  cl, 3
    shr  ax, cl
    add  ax, ax
    add  bx, ax
    mov  ax, di
    mov  cl, 3
    shr  ax, cl
    xor  ch, ch
    mov  cl, byte ptr ScreenWidth
    add  cx, cx
    mul  cx
    add  bx, ax
end;
(*DataCompBoy
procedure HideGraphCursor; {$IFDEF BIT_16}far;{$ENDIF} assembler;
asm
    cmp OldMouseX, 0
    js  @@1
    cmp MouseVisible, 0
    jz  @@1
    mov  si, OldMouseX
    mov  di, OldMouseY
    call MakeCoords
    lea  di, OldSymbols
    mov  si, cx
    mov  ax, word ptr ds:[di]
    cmp  byte ptr es:[bx], $D6
    jne  @@@1
    mov  es:[bx], al
@@@1:
    cmp  byte ptr es:[bx+2], $D7
    jne  @@@2
    mov  es:[bx+2], ah
@@@2:
    mov  ax, word ptr ds:[di+2]
    cmp  byte ptr es:[bx+si], $D0
    jne  @@@3
    mov  es:[bx+si], al
@@@3:
    cmp  byte ptr es:[bx+si+2], $D2
    jne  @@@4
    mov  es:[bx+si+2], ah
@@@4:
    add  si, si
    mov  ax, word ptr ds:[di+4]
    cmp  byte ptr es:[bx+si], $B7
    jne  @@@5
    mov  es:[bx+si], al
@@@5:
    cmp  byte ptr es:[bx+si+2], $B8
    jne  @@1
    mov  es:[bx+si+2], ah
    add  si, si
@@1:
end;
*)
procedure PrepareCharGen; assembler;
asm
 mov dx, $3C4
 mov ax, $0402
 out dx, ax
 mov ax, $0704
 out dx, ax
 mov dx, $3CE
 mov ax, $0005
 out dx, ax
 mov ax, $0406
 out dx, ax
 mov ax, $0204
 out dx, ax
end;

procedure DoneCharGen; assembler;
asm
 mov dx, $3C4
 mov ax, $0302
 out dx, ax
 mov ax, $0304
 out dx, ax
 mov dx, $3CE
 mov ax, $1005
 out dx, ax
 mov ax, $0E06
 out dx, ax
 mov ax, $0004
 out dx, ax
end;
(*DataCompBoy
procedure ShowGraphCursor; {$IFDEF BIT_16}far;{$ENDIF}
 var GraphBlock: Array[0..5,0..15] of Byte;
     I: Integer;
begin
 if not MouseVisible then Exit;
 asm
    call HideGraphCursor
    mov  si, MouseX
    mov  di, MouseY
    mov  OldMouseX, si
    mov  OldMouseY, di
    call MakeCoords
    lea  di, OldSymbols
    mov  si, cx
    mov  al, es:[bx]
    mov  ah, es:[bx+2]
    mov  ds:[di], ax
    mov  al, es:[bx+si]
    mov  ah, es:[bx+si+2]
    mov  ds:[di+2], ax
    add  si, si
    mov  al, es:[bx+si]
    mov  ah, es:[bx+si+2]
    mov  ds:[di+4], ax
 end;

 PrepareCharGen;
 for I := 0 to 5 do
  Move(mem[$A000:32*OldSymbols[I]], GraphBlock[I,0], 16);
 DoneCharGen;

 asm
  mov dx, MouseY
  and dx, 7
  cmp CharHeight, 14
  jl @@1
  add dx, dx
  cmp dl, CharHeight
  jl  @@1
  dec dx
@@1:
  lea si, GraphBlock
  add si, dx
  push dx
  mov  dx, MouseX
  and  dx, 7
  mov  cl, dl
  pop  ax
  mov  dl, al
  cmp  MouseMouse, 0
  jz   @STDMouse
  mov  al, LastMouseMouse
  xor  al, 1
  mov  LastMouseMouse, al
  jz   @@@1
  lea  di, MCurM1
  jmp  @@5
@@@1:
  lea  di, MCurM2
  jmp  @@5
@StdMouse:
  xor  bh, bh
  mov  bl, MouseButtons
  test bx, 1
  jz   @@4
  lea  di, MCurLP
  jmp  @@5
@@4:
  test bx, 2
  jz   @@6
  lea  di, MCurM0
  jmp  @@5
@@6:
  lea di, MCurMP
@@5:
  mov  ch, 16
@@2:
  xor al, al
  mov ah, ds:[di+16]
  not ah
  shr ax, cl
  not ax
  and ss:[si], ah
  and ss:[si+16], al
  xor al, al
  mov ah, ds:[di]
  shr ax, cl
  or  ss:[si], ah
  or  ss:[si+16], al
  inc di
  inc si
  inc bx
  inc dl
  cmp dl, CharHeight
  jl  @@3
  mov dx, 32
  sub dl, CharHeight
  add si, dx
  xor dx, dx
@@3:
  dec ch
  jnz @@2

 end;

 PrepareCharGen;
 for I := 0 to 5 do
  Move(GraphBlock[I,0], mem[$A000:32*StdMouseBlock[I]], 16);
 DoneCharGen;

 asm
    mov  si, MouseX
    mov  di, MouseY
    call MakeCoords
    mov  si, cx
    lea  di, StdMouseBlock
    mov  dx, MouseX
    mov  cl, 3
    shr  dx, cl
    inc  dx
    xor  dh, dh
    sub  dl, byte ptr ScreenWidth
    mov  ax, ds:[di]
    mov  es:[bx], al
    or   dx, dx
    jz  @@1
    mov  es:[bx+2], ah
@@1:mov  ax, ds:[di+2]
    mov  es:[bx+si], al
    or   dx, dx
    jz  @@2
    mov  es:[bx+si+2], ah
@@2:add  si, si
    mov  ax, ds:[di+4]
    mov  es:[bx+si], al
    or   dx, dx
    jz  @@3
    mov  es:[bx+si+2], ah
@@3:
 end;
end;
*)
procedure HideTextCursor; {$IFDEF BIT_16}far;{$ENDIF} assembler;
asm
    cmp OldMouseX, 0
    jl  @@1
    mov  si, OldMouseX
    mov  di, OldMouseY
    call MakeCoords
    mov  al, OldAttr
    inc  bx
    mov  es:[bx], al
@@1:
end;

procedure ShowStdCursor; {$IFDEF BIT_16}far;{$ENDIF} assembler;
asm
   mov ax, 1
   int 33h
end;
(*DataCompBoy
procedure HideStdCursor; {$IFDEF BIT_16}far;{$ENDIF} assembler;
asm
   mov ax, 2
   int 33h
end;
*)
procedure ShowTextCursor; {$IFDEF BIT_16}far;{$ENDIF} assembler;
asm
   call HideTextCursor
   cli
   mov  si, MouseX
   mov  di, MouseY
   mov  OldMouseX, si
   mov  OldMouseY, di
   call MakeCoords
   inc  bx
   mov  al, es:[bx]
   mov  OldAttr, al
   not  al
   and  al, $7F
   mov  es:[bx], al
   sti
end;


procedure MouseInt; {$IFDEF BIT_16}far;{$ENDIF} assembler;
asm
{$IFNDEF BIT_32}
        MOV     SI,SEG @DATA
        MOV     DS,SI
{$ELSE}
        LDS     SI,@DATA
{$ENDIF}
        MOV     SI,CX
        MOV     CL,3
        MOV     MouseX,SI
        MOV     MouseY,DX
        SHR     SI,CL
        SHR     DX,CL
        MOV     MouseButtons,BL
{$IFNDEF BIT_32}
        MOV     MouseWhere.X.Word[0],SI
        MOV     MouseWhere.Y.Word[0],DX
{$ELSE}
        MOV     MouseWhere.X,ESI
        MOV     MouseWhere.Y,EDX
{$ENDIF}
        TEST    AX,11110B
        JE      @@2
        CMP     EventCount,EventQSize
        JE      @@2
        MOV     ES,Seg0040
        MOV     AX,ES:[6Ch]
        MOV     DI,EventQTail
        PUSH    DS
        POP     ES
        CLD
        STOSW
        XCHG    AX,BX
        STOSW
        XCHG    AX,SI
        STOSW
        XCHG    AX,DX
        STOSW
        CMP     DI,OFFSET EventQLast
        JNE     @@1
        MOV     DI,OFFSET EventQueue
@@1:    MOV     EventQTail,DI
        INC     EventCount
@@2:    MOV     MouseIntFlag,1
end;

procedure MouseHandler; {$IFDEF BIT_16}far;{$ENDIF} assembler;
asm
        PUSHF
        PUSH    AX
        CLI
{$IFNDEF BIT_32}
        MOV     SI,SEG @Data
        MOV     DS,SI
{$ELSE}
        LDS     SI,@Data
{$ENDIF}

        MOV     MouseButtons, BL
        mov   ax, 0Bh
        int   33h

        add   cx, MouseX
        add   dx, MouseY

        cmp   cx, 0
        jnl   @@@2
        xor   cx, cx
  @@@2:
        cmp   dx, 0
        jnl   @@@3
        xor   dx, dx
  @@@3:
        mov   MouseX, cx
        mov   MouseY, dx
        mov   bx, cx
        mov   cl, 3
        shr   bx, cl
        cmp   bx, ScreenWidth
        jl    @@@4
        mov   bx, ScreenWidth
        dec   bx
        shl   bx, cl
        add   bx, 7
        mov   MouseX, bx
  @@@4:
        shr   dx, cl
        cmp   dx, ScreenHeight
        jl    @@@5
        mov   dx, ScreenHeight
        dec   dx
        shl   dx, cl
        add   dx, 7
        mov   MouseY, dx
  @@@5:
        cmp   MouseVisible, 0
        jz    @@@6
        les   bx, ShowMouseProc
        mov   ax, es
        or    bx, ax
        jz    @@@6
        call  ShowMouseProc
  @@@6:
        MOV     SI, MouseX
        MOV     DX, MouseY
        MOV     CL,3
        SHR     SI,CL
        SHR     DX,CL
        XOR     BH, BH
        MOV     BL, MouseButtons
{$IFNDEF BIT_32}
        MOV     MouseWhere.X.Word[0],SI
        MOV     MouseWhere.Y.Word[0],DX
{$ELSE}
        MOV     MouseWhere.X,ESI
        MOV     MouseWhere.Y,EDX
{$ENDIF}
        POP     AX
        TEST    AX,11110B
        JE      @@2
        CMP     EventCount,EventQSize
        JE      @@2
        MOV     ES,Seg0040
        MOV     AX,ES:[6Ch]
        MOV     DI,EventQTail
        PUSH    DS
        POP     ES
        CLD
        STOSW
        XCHG    AX,BX
        STOSW
        XCHG    AX,SI
        STOSW
        XCHG    AX,DX
        STOSW
        CMP     DI,OFFSET EventQLast
        JNE     @@1
        MOV     DI,OFFSET EventQueue
@@1:    MOV     EventQTail,DI
        INC     EventCount
@@2:    MOV     MouseIntFlag,1
        STI
        POPF
end;

procedure StdMouseHide; {$IFDEF BIT_16}far;{$ENDIF} assembler;
asm
   cmp MouseButtons, 0
   je  @@1
   push bp
   mov  ax, 1
   int  33h
   pop bp
 @@1:
end;

procedure StdMouseShow; {$IFDEF BIT_16}far;{$ENDIF} assembler;
asm
   cmp MouseButtons, 0
   je  @@1
   push bp
   mov  ax, 2
   int  33h
   pop bp
 @@1:
end;

procedure InstallMouseHandler(MouseHandler, ShowProc, HideProc: Pointer);
 var p : Pointer;
     I : Integer;
begin
 CharHeight := Mem[Seg0040:CrtCharOfs];
 (*
 {$ifndef DPMI}
 if EGAVGA then
  begin
   PrepareCharGen;
   for I := 0 to 5 do
    Move(mem[segA000:32*StdMouseBlock[I]], SaveFont[I], 16);
   DoneCharGen;
  end;
 {$endif}
 *)
 MouseX := 0;
 OldMouseX := $FFFF;
 OldMouseY := 0;
 MouseY := 0;
 p := MouseHandler;
 ShowMouseProc := ShowProc;
 HideMouseProc := HideProc;
 asm
  les dx,dword ptr p
  mov bx, dx
{  mov ax, ds
  mov es:[bx+2], ax}
  mov cx,$ff
  mov ax,12
  int 33h
 end;
end;

procedure UninstallMouseHandler;
 var I: Integer;
begin
 asm
    call HideMouseProc
    xor dx,dx
    mov es,dx
    xor cx,cx
    mov ax,12
    int 33h
 end;
 (*
 { $ifndef DPMI}
 if EGAVGA then
  begin
   PrepareCharGen;
   for I := 0 to 5 do
    Move(SaveFont[I], mem[segA000:32*StdMouseBlock[I]], 16);
   DoneCharGen;
  end;
 { $endif}
 *)
 ShowMouseProc := nil;
 HideMouseProc := nil;
end;

procedure StdInitEvents; assembler;
asm
        XOR     AX,AX
        CMP     AL,ButtonCount
        JE      @@1
        MOV     DownButtons,AL
        MOV     LastDouble,AL
        MOV     EventCount,AX
        MOV     AX,OFFSET EventQueue
        MOV     EventQHead,AX
        MOV     EventQTail,AX
        MOV     AX,3
        INT     33H
        XCHG    AX,CX
        MOV     CL,3
        SHR     AX,CL
        SHR     DX,CL
{$IFNDEF BIT_32}
        MOV     MouseButtons,BL
        MOV     MouseWhere.X.Word[0],AX
        MOV     MouseWhere.Y.Word[0],DX
        MOV     LastButtons,BL
        MOV     LastWhere.X.Word[0],AX
        MOV     LastWhere.Y.Word[0],DX
{$ELSE}
        MOV     MouseButtons,BL
        MOV     MouseWhere.X,EAX
        MOV     MouseWhere.Y,EDX
        MOV     LastButtons,BL
        MOV     LastWhere.X,EAX
        MOV     LastWhere.Y,EDX
{$ENDIF}
        MOV     AX,12
        MOV     CX,0FFFFH
        MOV     DX,OFFSET MouseInt
        PUSH    CS
        POP     ES
        INT     33H
        MOV     AX,1
        INT     33H
        MOV     MouseEvents,1
@@1:
end;

procedure InitEvents;
label 1;
var
  I: Integer;
begin
  if ButtonCount = 0 then Exit;
  StdMouse := ( MouseData.Options and omsCursor <> 0 ){ or ( ScreenWidth = 80 )};
  if StdMouse then begin
    if (ScreenWidth > 80) then begin
      I := mem[Seg0040:$49];
      mem[Seg0040:$49] := 3;
      asm
        push bp
        xor  ax, ax
        int  33h
        pop  bp
      end;
      mem[Seg0040:$49] := I;
    end;
    StdInitEvents;
    Goto 1
  end;
  asm
         XOR     AX,AX
         MOV     DownButtons,AL
         MOV     LastDouble,AL
         MOV     EventCount,AX
         MOV     AX,OFFSET EventQueue
         MOV     EventQHead,AX
         MOV     EventQTail,AX
         MOV     AX,3
         INT     33H
         MOV     CX, 0
         MOV     DX, 0
         XCHG    AX,CX
         MOV     CL,3
         SHR     AX,CL
         SHR     DX,CL
{$IFNDEF BIT_32}
         MOV     MouseButtons,BL
         MOV     MouseWhere.X.Word[0],AX
         MOV     MouseWhere.Y.Word[0],DX
         MOV     LastButtons,BL
         MOV     LastWhere.X.Word[0],AX
         MOV     LastWhere.Y.Word[0],DX
{$ELSE}
         MOV     MouseButtons,BL
         MOV     MouseWhere.X,EAX
         MOV     MouseWhere.Y,EDX
         MOV     LastButtons,BL
         MOV     LastWhere.X,EAX
         MOV     LastWhere.Y,EDX
{$ENDIF}
         MOV     MouseEvents,1
  @@1:
  end;
  InstallMouseHandler(@MouseHandler, @ShowTextCursor, @HideTextCursor);
1:
  SetMouseSpeed(XSens, YSens);
end;

procedure SetMouseSpeed(XS, YS: Byte);
 var I: Integer;
     J: Integer;

 function II(X: Byte): Integer;
 begin
    case X of
      0..11: II := X+1;
      12: II := 14;
      13: II := 16;
      14: II := 20;
      15: II := 24;
      16: II := 28;
      17: II := 32;
      18: II := 36;
      19: II := 40;
      20: II := 44;
      21: II := 48;
      22: II := 56;
    end;
 end;

begin
    XSens := XS; YSens := YS;
    I := ScreenWidth * (XSens+1);
    J := ScreenHeight * (YSens+1);
    I := 200 * 22 div I;
    J := 200 * 22 div J;
    asm
      mov  ax, $0F
      mov  cx, I
      mov  dx, J
      push bp
      int  33h
      pop  bp
    end;
end;

procedure StdDoneEvents; assembler;
asm
        CMP     ButtonCount,0
        JE      @@1
        CMP     MouseEvents,0
        JE      @@1
        MOV     MouseEvents,0
        MOV     AX,2
        INT     33H
        MOV     AX,12
        XOR     CX,CX
        MOV     DX,CX
        MOV     ES,CX
        INT     33H
@@1:
end;

procedure DoneEvents;
begin
  if (StdMouse) and (ButtonCount > 0) and (ScreenWidth > 80) then
       asm
          push bp
          xor  ax, ax
          int  33h
          pop  bp
       end;

 if StdMouse then begin StdDoneEvents; Exit; end;
 if (ButtonCount = 0) or not MouseEvents then Exit;
 MouseEvents := False;
 UninstallMouseHandler;
end;

procedure ExitDrivers; {$IFDEF BIT_16}far;{$ENDIF}
begin
  DoneSysError;
  DoneEvents;
     ExitProc := SaveExit;
      if ErrorAddr <> Nil then
          begin
{$IFDEF DNPRG}
           ErrAdd := Longint(ErrorAddr);
           ErrorAddr := Nil;
           FatalError;
{$ENDIF}
           DoneVideo;
          end;
end;

